---
title: "Handout 4"
output:
  pdf_document: default
  html_document: default
---

```{r global_options, include=FALSE}
knitr::opts_chunk$set(fig.width=8, fig.height=8, fig.align="center", echo=TRUE, warning=FALSE, message=FALSE)
library(knitr)
library(igraph)
library(yardstick)
library(ggplot2)
library(kableExtra)
```

**1) Generate an undirected random graph using the model of "preferential attachment" (sample_pa( )) of 1000 nodes. With $\beta=0.1$, $\gamma=0.1$, generate a SIR pandemic (iterative method). The initial infected nodes should be the 10 highest using the eigen_centrality( ). Compare the results to when the initial nodes are at random. Reduce or increase $\beta$ and compare. **

Se define el algoritmo del modelo SIR como se muestra a continuación:

```{r}
SIR_Model = function(x, beta, gamma){

  S = I - x - R
  R = R + gamma * x
  
  return (x + beta * S * (A %*% x) - gamma * x)
}
```

Se ejecuta el algoritmo SIR con un grafo aleatorio de 1000 vértices y los nodos infectados como los más 10 nodos más centrales según "*eigen_centrality()*". El algoritmo se ejecuta 25 iteraciones en total:

```{r}
#Generate random graph and obtain initial infected nodes
n = 1000
set.seed(1234)
g = sample_pa(n, power=1, directed=FALSE)
eigen_cent = order(eigen_centrality(g)$vector, decreasing = TRUE)
infected_n = head(eigen_cent, 10)

#Iteration 1 vector
x0 = rep(0, n)
x0[infected_n] = 1

#Initial values
beta = 0.1
gamma = 0.1
A = as.matrix(as_adjacency_matrix(g))
I = rep(1, n)
R = rep(0, n)
iter = 25
RX = matrix(0, nrow = n, ncol = iter)
RX[,1] = x0

#SIR model, 25 iterations
for (i in 2:(iter)){
  RX[,i] = SIR_Model(RX[,i-1], beta, gamma)
}

```

A continuación se realiza el experimento donde los 10 nodos infectados iniciales son escogidos aleatoriamente: 

```{r}
set.seed(1234)
infected_n2 = sample(V(g), 10)
#Iteration 1 vector
x0_Random = rep(0, n)
x0_Random[infected_n2] = 1

RX_Random = matrix(0, nrow = n, ncol = iter)
RX_Random[,1] = x0_Random

#SIR model, 25 iterations
for (i in 2:(iter)){
  RX_Random[,i] = SIR_Model(RX_Random[,i-1], beta, gamma)
}
```


Comparamos los resultados de ambas ejecuciones:

```{r echo = FALSE}
kable(as.data.frame(RX[1:5,1:10]), booktabs = T, caption = "Source infection: highly central nodes") %>%
  kable_styling(latex_options = "hold_position", font_size = 7)

kable(as.data.frame(RX_Random[101:106,1:10]), booktabs = T, caption = "Source infection: random nodes") %>%
  kable_styling(latex_options = "hold_position", font_size = 7)


infectedV2 = sum(RX[,2]) - 9

infectedV2_Random = sum(RX_Random[,2]) - 9

```


Centrándonos en los nodos inicialmente infectados, se puede observar en la primera tabla, que si estos son nodos altamente conexos o centrales, su nivel de recuperación no es muy bueno ya que tienen contacto con un gran número de los otros nodos del grafo. Es decir, al estar influenciados por más vecinos, su recuperación es más lenta con el paso de las iteraciones. En cambio, si nos fijamos en los nodos inicialmente infectados de la segunda tabla, los cuales son cogidos aleatoriamente, vemos que su recuperación es continua con el paso de las iteraciones y su nivel de infección va disminuyendo en cada una de ellas. Esto se debe a que, al ser nodos escogidos al azar, no tiene por qué ser nodos centrales o con una gran cantidad de vecinos, por lo que no se ven tan influenciados por estos y es más fácil que se recupere.


Por otro lado, si nos fijamos en los nodos que no estaban contagiados inicialmente (V1), podemos observar que en la segunda iteración de la tabla 1 hay un mayor número de infectados que en la tabla 2. Para medir los nuevos infectados, se ha sumado todas las infecciones de la segunda iteración en ambos casos y se le restan 9 puntos ya que es la parte aportada por los nodos infectados inicialmente (10x0,9), obteniendo los siguientes resultados:

- Infección con nodos centrales: `r infectedV2`


- Infección con nodos aleatorios: `r infectedV2_Random`

Se puede apreciar claramente como en el primer caso la infección se ha propagado a un mayor número de nodos en el grafo. Esto es debido, como en el caso anterior, a la centralidad y conectividad de los nodos infectados inicialmente. Ya que los más centrales tienen un mayor alcance hacia otros nodos, la infección se propaga rápidamente.



A continuación realizamos el mismo experimento cambiando el valor de beta a $\beta = 0.5$

```{r echo = FALSE}
beta = 0.5

RX_b0.5 = matrix(0, nrow = n, ncol = iter)
RX_b0.5[,1] = x0

#SIR model, 25 iterations
for (i in 2:(iter)){
  RX_b0.5[,i] = SIR_Model(RX_b0.5[,i-1], beta, gamma)
}

kable(as.data.frame(RX_b0.5[1:5,1:10]), booktabs = T, caption = "Source infection: highly central nodes") %>%
  kable_styling(latex_options = "hold_position", font_size = 7)

```
```{r echo = FALSE}
beta = 0.5

RX_Random_b0.5 = matrix(0, nrow = n, ncol = iter)
RX_Random_b0.5[,1] = x0_Random

#SIR model, 25 iterations
for (i in 2:(iter)){
  RX_Random_b0.5[,i] = SIR_Model(RX_Random_b0.5[,i-1], beta, gamma)
}

kable(as.data.frame(RX_Random_b0.5[101:106,1:10]), booktabs = T, caption = "Source infection: random nodes") %>%
  kable_styling(latex_options = "hold_position", font_size = 7)


infectedV2_b0.5 = sum(RX_b0.5[,2]) - 9

infectedV2_Random_b0.5 = sum(RX_Random_b0.5[,2]) - 9
```


Se observa que al aumentar el beta, la infección en la segunda iteración de los nodos que se han infectado pasa de 0.1 a 0.5, por lo que la propagación es más rápida. Al hacer uso de la métrica explicada anteriormente obtenemos:

- Infección con nodos centrales: `r infectedV2_b0.5`


- Infección con nodos aleatorios: `r infectedV2_Random_b0.5`


Se observa claramente que en la segunda iteración la puntuación de la infección, en relación a los valores obtenidos cuando beta era 0.1, ha incrementado notablemente.

```{r}

#Graph chart
V(g)$prob = as.matrix(RX)
V(g)[V(g)$prob < 0.5]$color = "chartreuse3"
V(g)[V(g)$prob < 0.5]$color = "khaki1"
V(g)[V(g)$prob > 0.5]$color = "firebrick1"
plot(g)

#Point chart
df = as.data.frame(as.matrix(RX))
ggplot(df, aes(x = c(1:n), y = V1)) +
  geom_point(aes(color = V1)) +
  scale_colour_gradient(low="chartreuse3", high = "firebrick1")
```













**2)** Consider the random graph generated in the previous exercice. 

*a)* Plot its degrees distribution in linear and in log-log scale. Which is more helpful to understand this distribution?

*b)* Does the degree distribution follows a Power Law? And if we consider only the nodes with degree above 5? (or 10? or 100?)

*c)* Find the best line that approximates the degree distribution after degree 10 (or 5?) using linear regression ( lm() ) on the log-log plane. Don't worry, it is almost all done in the following code. Explain in detail each line of the following code:
```{r, eval=FALSE}
D=degree_distribution(GRAPH) 
xx=which(D>0)[-(1:10)]  # remove the first 10 prob values
lyy=log(D[xx])
lxx=log(xx)
LMI=lm(lyy~lxx)$coefficients  # line coefficients
plot(D,pch=20,cex=0.7,xlab="Degree",ylab="Frequencies",main="degrees",log="xy")
points(exp(lxx),exp(LMI[1]+LMI[2]*lxx),col="red",type="l",lwd=2)
```

*d)* What is the exponent of the Power Law for the degree probabilities?


**3)** Use the routine sample_pa( ) to generate a rich-get-richer (preferential attachment) graph with similar degree distribution of  the *directed* facebook graph of the file **facebook_sample_anon.txt**. Use the code similar to:
sample_pa(n.GRAPH, out.seq=degree(GRAPH,mode="out"))
Plot the degree distribution of the generated graph (log-log). What is the exponent of the power law of the generated graph for the in-degrees? 