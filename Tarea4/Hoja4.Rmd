---
title: "Handout 4"
output:
  pdf_document: default
  html_document: default
---

```{r global_options, include=FALSE}
knitr::opts_chunk$set(fig.width=8, fig.height=8, fig.align="center", echo=TRUE, warning=FALSE, message=FALSE)
library(knitr)
library(igraph)
library(yardstick)
library(ggplot2)
```

**1) Generate an undirected random graph using the model of "preferential attachment" (sample_pa( )) of 1000 nodes. With $\beta=0.1$, $\gamma=0.1$, generate a SIR pandemic (iterative method). The initial infected nodes should be the 10 highest using the eigen_centrality( ). Compare the results to when the initial nodes are at random. Reduce or increase $\beta$ and compare. **



```{r}
SIR_Model = function(x, beta, gamma){

  S = I - x - R
  R = R + gamma * x
  
  return (x + beta * S * (A %*% x) - gamma * x)
}
```

```{r}
#Generate random graph and obtain initial infected nodes
n = 1000
set.seed(1234)
g = sample_pa(n, power=1, directed=FALSE)
eigen_cent = order(eigen_centrality(g)$vector, decreasing = TRUE)
infected_n = head(eigen_cent, 10)

#Iteration 1 vector
x0 = rep(0, n)
x0[infected_n] = 1

#Initial values
beta = 0.1
gamma = 0.1
A = as.matrix(as_adjacency_matrix(g))
I = rep(1, n)
R = rep(0, n)
iter = 25
RX = matrix(0, nrow = n, ncol = iter)
RX[,1] = x0

#SIR model iterations
for (i in 2:(iter)){
  RX[,i] = SIR_Model(RX[,i-1], beta, gamma)
}

```


```{r}
set.seed(1234)
infected_n2 = sample(V(g), 10)
#Iteration 1 vector
x0 = rep(0, n)
x0[infected_n2] = 1

RX_Random = matrix(0, nrow = n, ncol = iter)
RX_Random[,1] = x0

#SIR model iterations
for (i in 2:(iter)){
  RX_Random[,i] = SIR_Model(RX_Random[,i-1], beta, gamma)
}
```



```{r}

#Graph chart
V(g)$prob = as.matrix(RX)
V(g)[V(g)$prob < 0.5]$color = "chartreuse3"
V(g)[V(g)$prob < 0.5]$color = "khaki1"
V(g)[V(g)$prob > 0.5]$color = "firebrick1"
plot(g)

#Point chart
df = as.data.frame(as.matrix(RX))
ggplot(df, aes(x = c(1:n), y = V1)) +
  geom_point(aes(color = V1)) +
  scale_colour_gradient(low="chartreuse3", high = "firebrick1")
```













**2)** Consider the random graph generated in the previous exercice. 

*a)* Plot its degrees distribution in linear and in log-log scale. Which is more helpful to understand this distribution?

*b)* Does the degree distribution follows a Power Law? And if we consider only the nodes with degree above 5? (or 10? or 100?)

*c)* Find the best line that approximates the degree distribution after degree 10 (or 5?) using linear regression ( lm() ) on the log-log plane. Don't worry, it is almost all done in the following code. Explain in detail each line of the following code:
```{r, eval=FALSE}
D=degree_distribution(GRAPH) 
xx=which(D>0)[-(1:10)]  # remove the first 10 prob values
lyy=log(D[xx])
lxx=log(xx)
LMI=lm(lyy~lxx)$coefficients  # line coefficients
plot(D,pch=20,cex=0.7,xlab="Degree",ylab="Frequencies",main="degrees",log="xy")
points(exp(lxx),exp(LMI[1]+LMI[2]*lxx),col="red",type="l",lwd=2)
```

*d)* What is the exponent of the Power Law for the degree probabilities?


**3)** Use the routine sample_pa( ) to generate a rich-get-richer (preferential attachment) graph with similar degree distribution of  the *directed* facebook graph of the file **facebook_sample_anon.txt**. Use the code similar to:
sample_pa(n.GRAPH, out.seq=degree(GRAPH,mode="out"))
Plot the degree distribution of the generated graph (log-log). What is the exponent of the power law of the generated graph for the in-degrees? 